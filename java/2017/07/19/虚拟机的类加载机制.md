#### 虚拟机的类加载机制

虚拟机的类加载机制就是虚拟机把描述的类的数据从class文件加载到内存中去，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型；

* 类加载的时机

  ![屏幕快照 2017-07-19 上午9.46.01](/Users/mac/Desktop/屏幕快照 2017-07-19 上午9.46.01.png)

  类从被加载到内存开始，到卸载出内存为止，一共经历了上面这7个阶段

  也是他的整个生命周期，

  其中 加载，验证，准备，初始化，卸载 这5个阶段的顺序是确定的，而解析阶段不一定，：它可 i在初始化之后再开始，这是为了支持java语言的运行时绑定。

  *   [Java](http://lib.csdn.net/base/java)的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。**如果编译时类型和运行时类型不一致，会出现所谓的多态**。因为子类其实是一种特殊的父类，因此java允许把一个子类对象直接赋值给一个父类引用变量，无须任何类型转换，或者被称为**向上转型**，由系统自动完成。   引用变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行它运行时类型所具有的方法，因此，编写Java代码时，引用变量只能调用声明该变量所用类里包含的方法。与方法不同的是，对象的属性则不具备多态性。通过引用变量来访问其包含的实例属性时，系统总是试图访问它编译时类所定义的属性，而不是它运行时所定义的属性。

     —— 以上摘自《疯狂Java讲义》

* 类加载过程

  * 加载

    加载阶段需要完成以下3件事

    1:通过一个类的全限定名来获取定义这个类的二进制字节流

    2:将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

    3:在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

    加载完成之后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法之中，方法区中的数据存储格式是由虚拟机实现自定义的，然后在内存中实例话一个java.lang.Class类的对象（没有明确规定存放在java heap 中）对于Hotspot虚拟机，是把它放在方法区里面的，这个对象将作为程序访问方法区中这些类型数据的外部接口，

  * 验证

    这一个阶段的目的就是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，

    * 文件格式验证

      这个阶段要验证字节流是否符合Class文件格式规范，并且能否被当前版本虚拟机处理。

      * 是否以魔数oxCAFFEBABE开头

      * 主次版本号是否在当前虚拟机处理范围之内

      * 常量池的常量是否有不被支持的常量类型；

        。。。。

    * 元数据验证

      第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，这个阶段包括

      * 这个类是否有父类；
      * 这个类是否继承了不被允许继承的类；
      * 如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法
      * 类中的字段，方法是否与父类产生矛盾；

    * 字节码验证

      第三阶段是最复杂的阶段，主要通过数据流河控制流分析，确定程序语义是合法，符合逻辑的

      * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似：在操作数栈放置了一个int类型，使用的时候却按照long类型加载入本地变量表；
      * 保证跳转指令不会跳到方法体以外的字节码指令上面，

    * 符号引用验证

      最后一个阶段的校验发生在虚拟机将符号引用转化为直接  引用的时候，符号引用验证可以看成是对类自身以外的信息进行匹配性校验

      * 符号引用中通过字符串描述的全限定名是否存在对应的类

      * 在指定类中是否存在符合方法的字段描述以及简单的名称所描述的方法和字段

        。。。。。

  * 准备

    准备阶段是正式为类变量分配内存并设置类变量初始值阶段，这些变量所使用的内存都将在方法区中进行分配（这里进行内存分配的只是类变量（被static修饰的变量）不包括实例变量，实例变量将会在对象实例化 的时候随着对象一起分配到java堆中）还有就是这里的初始值“通常情况”下是数据类型的零值；还有就是一种特殊情况，如果这个是一个ConstantValue属性，那么在准备阶段就会被初始化为ConstantValue属性所指示的值，并且已经储存到了常量池中了；

  * 解析

    解析就是虚拟机将常量池内的符号引用替换成直接引用的过程

    * 符号引用

      符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候能无歧义的定位到目标就可以了；引用的目标不一定加载到了内存中，

    * 直接引用

      直接引用可以是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，而且有了直接引用那么目标一定是已经在内存中了。

  * 初始化

    类初始化是类加载过程的最后一步了这个时候才真正开始执行类中定义的java程序代码

    在准备阶段，变量已经被赋过一次系统要求的初始值了，在初始化阶段，就是执行类构造器的<clinit>()方法的过程，

    ​