### 编译器的指令重排序问题

##### 什么是指令的重排序？

重排序 是编译器的一种优化 就是 将程序语句执行的顺序在规定允许内进行一些调整 （在单线程运行时候可以不考虑指令的重排序问题 因为结果是不会发生变化的）

##### 为什么要重排序？

举一个例子 ：

int a =5；／／语句1

int b =6；/／语句2

int c =a+1；/／语句3

看上面的程序 如果按照顺序下来的话 在执行语句1 的时候 把 a 赋值后从内存中读取来放到寄存器里面 假设用同一个寄存器 然后 执行语句2 的时候 要把 a 取出来 b 放进去 ，执行语句3 的时候 又要将b 取出来 将a 放进去 再进行相加后 得到c 这中间就对寄存器 进行了重复的 读取 如果把语句2和语句3交换一下位置 就可以减少对寄存器的读取了

##### 一个令人着急的死循环

7.4.![7.4.1](/Users/mac/Desktop/7.4.1.png)

打印结果是 stop true 

今天在看java并发编程的时候 讲到 volatile 的时候 有上面这个例子

当stop没有定义volatile的时候 是死循环的 然后我查了《深入了解java虚拟机》这本书 书上是说 并发的时候 是有2 个内存 一个是主内存 一个是线程工作内存 线程对一系列变量操作都是对工作内存里面的变量进行的（工作内存里面的变量是主内存里面的变量的拷贝：并不是把所有对象都拷贝 只是对对象的引用，以及访问到的字段进行可能性的拷贝）怎么拷贝的可以查看相关书籍或者jvm规范或者我的下一篇博客；

上面死循环 打印出来的是  stop true 说明主存中已经是 stop=true 了

那为什么还会死循环呢？一开始我以为是 没有去读主存的原因 可是水平有限啊 反编译 看不懂 百度了一下 原来是 指令重排序的鬼 把原来的

while(!stop){

 	i++;

}

变成了

if（！stop）{

while(true){

​         i++

​	}

}

因为中间并没有对i 进行处理 就先判断去了 而判断的时候 stop还没write到主存中 所以读到了 false 之后就死循环了

ps：学习下汇编 一定要！！

