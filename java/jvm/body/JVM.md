#####对象的创建过程

	
虚拟机遇到一条new指令的时候首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用是否被加载，解析，和初始化过，
	
* 对象分配内存的时候

	若java堆内存规整 就使用“指针碰撞”
	
	若java堆内存不规整 就使用“空闲列表”

	#####注意：对象在创建过程中。即使是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象A分配内存的时候指针还未来得及修改，对象b用了相同的指针来分配内存，这个时候就会造成内存冲突而覆盖了其中一个对象，这时候有2种解决方案：一种是分配的时候同步处理——使用CAS配上失败重试保证原子性；另外一种就是把内存分配的动作按照线程划分在不同的空间之中分配预留的本地线程叫“TLAB” 还有就是分配内存和init初始化分为两步所以在对象发布的时候需要注意；
* JVM配置

//堆设置 
-Xms:初始堆大小 

-Xmx:最大堆大小 

-XX:NewSize=n:设置年轻代大小 

-XX:NewRatio=n:设置年轻代和年老代的比值.如:为3,表示年轻代与年老代比值为
1:3,年轻代占整个年轻代年老代和的1/4 

-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值.注意Survivor区有两个.如:3,表示Eden:Survivor=3:2,一个Survivor区占整个年轻代的1/5 

-XX:MaxPermSize=n:设置持久代大小

//收集器设置 

-XX:+UseSerialGC:设置串行收集器 

-XX:+UseParallelGC:设置并行收集器 

-XX:+UseParalledlOldGC:设置并行年老代收集器 

-XX:+UseConcMarkSweepGC:设置并发收集器

//垃圾回收统计信息 

-XX:+PrintGC 

-XX:+PrintGCDetails 

-XX:+PrintGCTimeStamps 

-Xloggc:filename

//并行收集器设置 

-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集//线
程数. 

-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 

-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n)

//并发收集器设置 

-XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况. 

-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用
的CPU数.并行收集线程数.


#####JVM中的引用

* 强引用：


	它就是指在程序代码之中普遍存在的，类似 Object obj = new Object();这类引用 只要引用还在，就永远不会回收被引用的对象

* 软引用


	用来描述一些有用但是非必须对象的对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常，在jdk1.2之后，提供了WeakReference类来实现软引用；
	
* 弱引用
	
	也是用来描述非必需对象的，但是他的强度比软引用还要弱一点。弱引用对象只能生存到下一次垃圾回收发生之前；这个时候无论够不够内存都会被回收

* 虚引用

	他是最弱的一种引用。一个对象是否有虚引用的存在。完全不会对其生存时间构成影响，也无法通过虚引用来取的一个对象实例，唯一的作用就是能在这个对象被GC的时候收到系统通知 在jdk1.2之后提供了PhantomReference类提供实习虚引用

#####方法区的回收

	
* 永久代的回收主要回收两个部分：废弃的常量和无用的类，回收常量和堆中回收对象非常类似的。假如一个字符串“abc”
已经进入了常量池中，但是当前的系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何对象引用常量池中的“abc”常量，如果这个时候发生内存回收。而且必要的话，这个“abc”就会 被回收，常量池中其他的类也是相同的处理方式

#####类的GC
* 无用类的定义

	* 该类的所有实例对象都被GC
	* 加载该类的ClassLoader已经被回收
	* 该类对应的java.lang.Class对象，没有被任何地方引用，也就是说没有任何一个地方通过反射来访问这个类
	
#####垃圾收集算法

* 标记-清除算法

	这个算法分为两个阶段： 标记和清除 （在标记完成之后统一回收被标记的对象）
	
	缺点：

	第一，效率问题，标记和清除的两个过程效率都不高
	
	第二，空间碎片问题，会产生大量不连续的内存空间碎片，会导致之后若有较大的对象的时候会另外产生一次GC

* 复制算法

	它将内存按照容量划分为相等的两块。每次只使用其中一块。当这块内存用完的时候就将还存活的对象复制到另一个区域之后再把已经使用过的内存空间一次清理掉

	优点：解决了空间碎片的问题。实现简单并且高效
	
	缺点：内存浪费严重，代价太高

	解决方案：

	经过IBM公司的专门研究表明，新生代中的对象98%都是“朝生夕死”。所以不要按照1：1划分空间，将内存划分为一个Eden区和两块Survivor空间；每次使用一个Eden和一个Survivor，当回收的时候将Eden和Survivor上面存活的对象一次性复制到另一块Survivor上面然后清理Eden和原来Survivor上面的对象，默认Eden和Survivor比值为8：1所以只有10%的空间被浪费了，当然当Survivor空间不够用的时候就需要依赖其他内存（老年代）来进行分配担保了
	
* 标记-整理算法

	因为老年代对象存活率较高。若使用复制算法，每一次需要复制的对象较多，效率将会变得较低而且老年代没有额外的空间进行担保所以不适用复制算法，根据老年代的特点，有人提出了一种 标记-整理算法；

	 标记-整理算法：这个算法标记和“标记-清理算法”一样。但是在清理前先对所有的对象进行整理，将所有存活的对象向一端移动，然后清理端边以外的内存。

* 分代收集算法

	这个算法就是根据各个年代的特点采用不同的收集算法。在新生代中、采用复制算法 老年代中采用标记-清理或者标记-整理算法

#####GC安全点

* 安全点：就是程序执行的时候并不是所有地方都能GC的必须要在安全点停顿GC（停顿的原因是不能在GC的时候引用关系还在不停的变化）安全点不能太少，导致GC等待时间太长，安全点不能太多，不然会过分增加运行时的负荷
	
* 问题：如何让所有线程（不包括JNI线程）在GC的时候都跑到安全点
	* 一：抢先式中断 

	GC的时候将所有线程中断，若发现有些中断的线程不在安全点上，恢复他 让他跑到安全点上

	* 二：主动式中断

	主动式中断的思想是当GC的时候不直接对线程操作，而是简单的设置一个标记位，每一个线程执行的时候都去轮询他发现中断标记为true的时候就挂起，中断标记和安全点重合

#####安全区域

安全区域是为了解决那些那些没有执行的程序，也就是没有分配到CPU的线程准备的。

在线程执行到安全区域的时候，先要标记自己已经进入了安全区域，当这段时间要发生GC的时候，就标记自己为安全区域状态线程，在离开安全区域的时候，要检查是否完成了整个GC 如果完成了就继续执行，反之就继续GC

#####垃圾收集器

* Serial收集器

	Serial收集器是一个单线程收集器。它在收集的时候其他工作线程必须停止，直到它收集结束。

	优点：简单高效对于限定的单CPU环境来说，没有线程交互开销专心收集垃圾，可以获得最高的单线程收集效率
	
	缺点：停顿时间使得用户体验不佳。目前只有在Client模式下使用了
* ParNew收集器

	ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外。其余都和Serial收集器完全一样。他是除了Serial收集器之外能和CMS收集器配合使用的收集器。
* Parallel Scavenge收集器

	他是一个新生代收集器，使用的是复制算法，又是并行的多线程收集器，

	特点：CMS等收集器的关注点尽可能的缩短收集时候用户的停顿时间，而Parallel Scavenge收集器重点在达到一个可控制的吞吐量，
* Serial Old收集器

	Serial Old收集器就是Serial的老年版本同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用
*  Parallel Old收集器

	Parallel Old收集器是 Parallel Scavenge收集器的老年版本 使用多线程“标记-整理”算法 他是配合 Parallel Scavenge收集器使用的，使得吞吐量得到提升
* CMS收集器

	号称停顿时间最短的收集器，他是一种以获取最短停顿时间为目标的收集器

	收集过程：

	* 初始标记
	* 并发标记（进行GCRoots Tracing 的过程）
	* 重新标记
	* 并发清除

	其中前面两个步骤还是需要“Stop The World”

	缺点：

	CMS收集器对CPU资源非常敏感。导致用户程序执行速度下降

	

	CMS收集器无法处理浮动垃圾。因为程序运行的时候也还会有新的垃圾产生。CMS无法在当次GC他们并且因为要预留足够的空间给用户线程使用所以需要预留一部分空间，导致他到了大约68%的时候就要一次FULLGC

	CMS收集器是标记清除的算法，有空间碎片产生
* G1收集器

	特点：

	并行与并发：G1充分利用多CPU，缩短“Stop The World”时间

	分代收集：G1可以独立管理整个GC堆
	
	空间整合：G1使用得是标记整理算法局部上看是复制算法

	可预测停顿：能让使用者明确在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

	在G1中将整个java堆分为多个大小相等的独立区域Region 虽然还保留着新生代老年代的概念，但是他们不再是物理隔离了

#####理解GC日志
[GC (Allocation Failure) [PSYoungGen: 32691K->889K(38400K)] 32691K->897K(125952K), 0.0031753 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		

	PSYoungGen表示是采用Parallel Scavenge收集器 
	32691K->889K(38400K)表示新生代总共有38400k空间 GC前使用了32691 GC后889
 	32691K->897K(125952K)表示java堆总共有125952k空间 GC前使用了32691 GC后897
 	0.0031753 secs表示时间为 0.0031753秒
	
#####对象GC时刻

大多数情况下，对象在新生代Eden区分配，若Eden中没有足够的空间进行分配，虚拟机将会发起一次MinorGC

大对象直接进入老年代

长期存活对象进入老年代

空间分配担保：在发生MinorGC前会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立那么久MinorGC如果不成立就会查看HandlePromotionFailure设置值是否允许担保失败，如果允许就会查看老年代最大连续空间是否大于历次晋升的对象平均大小，若成立那么久MinorGC否则不会冒险，这时候就会进行一次Full GC
	
	
	