#### JVM内存模型

说到java的特点 少不了说下JVM 跨平台的特性 让java 成为了最受欢迎的语言，而现在只有java 能跨平台吗？ 不是的 只要是能够在JVM上面跑起来的语言都可以跨平台 那么 jvm 为什么可以实现跨平台？

Jvm类似一种容器，不一样的平台有不一样的容器 而你只需要把你的代码放到相应的容器上面 这样子 就可以在相应的平台上面跑起来了 ；

![07.08.1](/Users/mac/Desktop/07.08.1.png)

这个是JVM 运行java时候的启动流程 一个java.class文件 经过装载 根据当前的路径寻找对应的JVM.cfg这个配置文件，根据配置文件寻找JVM.dll,初始化JVM 并找到main方法 开始跑程序；



![07.08.2](/Users/mac/Desktop/07.08.2.png)图二是JVM的运行时数据区，下面一个一个分析

##### PC寄存器

程序计数器：是一个比较小的内存空间，是线程私有的 永远指向下一条指令，也是通过它来完成一系列的循环，分支，跳转，异常处理线程恢复等基础功能，

JAVA 虚拟机栈

这个和pc寄存器一样也是线程私有的生命周期和线程一样 线程一开启就创建了，当方法执行的时候 就会创建一个栈帧用来储存局部变量表，操作数栈，动态链接，方法出口，

局部变量表是一个很重要的概念：

它包含着各种数据类型：boolean int byte char short float double long ，对象引用（reference 类型）它并不是一个对象，<font colour="red">可能是一个指向对象起始位置的引用指针。也可能是指向一个对象的句柄或其他与此对象相关的位置 </font> 还有 returnAddress类型（指向了一条字节码指令的地址）

其中64位的long 和double 类型 需要2 个slot 一个slot是32 位的大小

reference是一个引用所以只是一个slot；他是在编译的时候就确定了的

##### 本地方法栈

它的作用和JAVA虚拟机栈的作用差不多，只不过虚拟机栈是执行java方法的，而本地的使用的是Native方法服务

##### JAVA堆

这是一个很重要的内存，它是线程共享的 它的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配了内存，（栈上分布 标量替换优化技术 使其变的不那么绝对了）

###### 栈上分配

  JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。 
  栈上分配的一个技术基础是进行逃逸分析，逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。另一个是标量替换，允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。 
  只能在server模式下才能启用逃逸分析，参数`-XX:DoEscapeAnalysis`启用逃逸分析，参数`-XX:+EliminateAllocations`开启标量替换（默认打开）。在JDK 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项`-XX:+PrintEscapeAnalysis`查看逃逸分析的筛选结果。

JAVA堆那么重要还有一个原因就是这里是GC主要区域 也叫—“GC堆”

CG技术现在已经十分成熟了使用的是分代算法  JAVA堆被分成了 

Eden 空间——From Survivor——To Survivor——Old 

![07.08.3](/Users/mac/Desktop/07.08.3.png)

其中分配算法下次讨论；

从内存分配的的角度来看 线程共享的JAVA堆会划分出多个线程私有的分配缓冲区 TLAB；

###### TLAB

JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。
也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。

##### 方法区

它也是一个线程共享的区域，用于储存已被虚拟机加载的类信息，常量，静态变量等数据；有一些人喜欢把方法区称为永久代，本质上其实不相等，因为HotSpot虚拟机团队把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样GC也管理着方法区，如果没有管理也容易造成内存溢出问题，

##### 运行时常量池

运行时常量池是方法区的一部分；用来存放编译期生成的各种字面量和符号的引用， 对于运行时常量池java虚拟机没有任何细节的要求，他有一个重要的特性具备动态性，

